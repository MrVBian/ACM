专题十一 网络流


//https://blog.csdn.net/qq_34921856/article/details/79570542


1 A POJ 3436 ACM Computer Factory
题意：
    第一行给你P和N， P表示配件的个数， N表示机器的数量，机器可用来组装电脑，把进来时拥有的配件变成出去时的配件。
    其中进入的电脑配件有三种情况：
        1：已配置 0：没配置 2：配置没配置都行。
    从机器中出去的电脑配件有两种情况：
        1：已配置 0：没配置
    输出最大组装电脑数方案的路径
思路：
    网络流模型：
    1) 添加一个原点S,S提供最初的原料 00000...
    2) 添加一个汇点T, T接受最终的产品 11111...
    3) 将每个机器拆成两个点: 编号为i的接收节点，和编号为i+n的产出节点（n是机器数目），前者用于接收原料，
       后者用于提供加工后的半成品或成品。这两个点之间要连一条边，容量为单位时间产量Qi
    4) S 连边到所有接收 "0000..." 或 "若干个0及若干个2" 的机器，容量为无穷大
    5) 产出节点连边到能接受其产品的接收节点，容量无穷大
    6) 能产出成品的节点，连边到T，容量无穷大。
    7) 求S到T的最大流


2 B POJ 3281 Dining
题意：
    有n头牛，F种食物，D种饮料，每一头牛都有自己喜欢的食物和饮料，且每一种食物和饮料都只有一份，让你分配这些食物和饮料，
    问能使多少头牛同时获得自己喜欢的食物和饮料。
思路:
    sp->食物->牛->牛->饮料->tp。牛到牛防止一头牛选择多种方案。


3 C POJ 1087 A Plug for UNIX
题意：
    一间屋子里有n种插座，每种插座有唯一的名称，且数量只有一个，在这个屋里可能会要使用m种电器，
    每种电器名称也是唯一，而且也只有一个，需要一种插座，市面上有t种插座适配器，其需要一个插座，
    同时也提供一个插座，数量不限，问最少有多少电器会因没有插座无法使用。
思路：
    建一个源点，指向所有设备，容量为1
    将源点指向设备，容量为1
    如果一个设备可以插到一个插座，那么设备指向插座，容量为1
    如果一个插座a可以插到另一个插座b，那么将a指向b，容量为无限大
    将插座指向汇点，容量为1


4 D POJ 2195 Going Home
题意：
    给你一个n*m的地图，H代表这个点有一个房子，m代表这个点是一个人，每次h走一步就花费一，
    问最小花费使得每个人能进入一个房间
思路：
    建立一个源点和汇点，每个人和源点相连，每个房子和汇点相连，每个人和每个房子相连，花费为曼哈段距离


5 E POJ 2516 Minimum Cost
题意：
    有n个供应商，m个店主，k种物品。每个供应商对每种物品的的供应量已知，每个店主对每种物品的需求量的已知，
    从不同的供应商运送不同的货物到不同的店主手上需要不同的花费，又已知从供应商mj送第k种货物的单位数量到
    店主mi手上所需的单位花费。
    问：供应是否满足需求？如果满足，最小运费是多少？
思路：
    0 -> 供应地 -> 店家 -> n+m+1
    题目非常非常绕！详细见注释。
    跑k次网络流，计算出每种物品的最小费用最大流，累计即答案。


6 F POJ 1459 Power Network
题意：
    给你n个点，其中有np个是能提供电力的点，nc个是能消费电力的点，剩下的点(n-np-nc)是中转战即不提供电力也不消费电力，
    点与点之间是有线路存在的，有m条线路，每条线路有最多运载限定。 
    前4个数据就是有n个点，np个供电点,nc个消费点,m条线路，
    接来题目先给出的是m条线路的数据，(起点,终点)最多运载量,然后是np个供电点的数据(供电点)最多供电量，
    接着就是nc个消费点的数据(消费点)最多消费电量。 
    题目要我们求出给定的图最大能消费的总电量（就是求最大流）
思路：
    超级源点->供电站->用电站->超级汇点
    最大网络流
注意：
    此题的输入(1,0)10前可能有不止一个空格。


7 G HDU 4280 Island Transport
题意：
    在n个岛屿中，有m条双向航线，现在求从最西侧到最东侧的最大运输量航线单位时间内的运输上限。
思路：
    注意的是这是一个双向图，在建立相反边的时候，权值就不是0了，而是跟正向边权值相等；
    网络流最大流，卡时，需要优化。


8 H HDU 4292 Food
题意：
    有n个人，F种食品，D种饮料，接下来一行表示F种食品的数量，再下一行D种饮料的数量，
    接下来的N行F列表示N个人对F种食品的可以接受情况：Y为可接受，N为不可接受。再接下来
    n行D列表示n个人对D种饮料可以接受的情况，Y与N和上面的代表相同。问最多能满足多少人，
    一人任意一种可接受的一个食品和一杯饮料。
思考：
    0 -> 食物 -> 人 -> 人 -> 饮料
注意：
    人到人容量设为1，防止一人多份食物饮料
    0到食物设为v，为食物的存量，食物到人设为inf。// 二者可替换，但不可同时设为v。
    人到饮料设为v，为饮料存量。


9 I HDU 4289 Control
题意：
    给出一些点，每个点有一个权值，给出一些边，起点以及终点，去掉一些点使得起点和终点不连通，求最小的花费。
思路：
    拆点，把一个点s拆成s和s'，之间建一条边，权值为点权。 对于一条边，
    <u, v>建边，<u, v'>、<v, u'> 权值为inf， 跑一遍最大流。
    最小割 == 最大流


10 J UVA 10480 Sabotage
题意：
    现在有n个城市，m条路，现在要把整个图分成2部分，编号1，2的城市分成在一部分中，拆开每条路都需要花费，
    现在问达成目标的花费最少要隔开那几条路。
题解：
    无向图最大流
    最小割 == 最大流
    bfs k次后，城市1到城市2无增广路，此时城市1相关的城市有分层dis，城市2相关的城市被分割无分层dis
    遍历存在边的情况如a、b之间有边，然而a、b有且只有一个有分层dis，则为割边，输出。


11 K HDU 2732 Leapin' Lizards
题意:
    给你一个网格n*m，网格上的一些位置上有一些蜥蜴，所有蜥蜴的最大跳跃距离是d
    如果一只蜥蜴能跳出网格边缘，那么它就安全了。每个网格有一个最大跳跃次数v，
    即最多有v只蜥蜴从这个网格跳出。这个网格就再也不能有蜥蜴进来了，问你最少有多少只蜥蜴跳不出网格
思路：
    源点sp编号0，网格的每个格子分成两个点i*m+j和n*m+i*m+j
    前者表示蜥蜴进来，后者表示蜥蜴出去。汇点tp编号2*n*m+1
    建图：
        如果格子上有蜥蜴，那么从sp到i*m+j有边(sp, i*m+j, 1)
        如果格子i*m+j能承受v次跳出，那么有边(i*m+j, n*m+i*m+j, v)
        如果从格子i*m+j能直接跳出网格，那么有边(n*m+i*m+j, tp, inf)
        如果从格子i*m+j不能直接跳出网格，那么离i*m+j距离<=d的网格(x,y)有边(n*m+i*m+j, x*m+y, inf)
            注意这里的距离是曼哈顿距离
    最大流就是能跳出网格的蜥蜴数。


12 L HDU 3338 Kakuro Extension
建图太复杂略


13 M HDU 3605 Escape
题意：
    有n个人，m个星球，有一个n*m的矩阵，表示第i个人是否可以去第j个星球
    问你这些人能不能全安排到这些星球上？
思路：
    缩点/状态压缩，因为n取值上限太大了，每个人都建一个点会超内存的，考虑m的上限很小（<=10），
    对所有人而言，去星球的状态最多2^m = 1<<m种，所以每种状态建一个点（每种状态代表一类人，这类人完全等价）。
    输入给的是01序列，所以正好由这一行二进制得出十进制的状态编号，这个相当于压缩的过程。
    注意在对状态编号解压时要按照相同的位处理顺序
    （解压就是判断状态编号的二进制表示中某一位是不是1，用if( (v >> j) & 1 )来判断二进制j位是不是1）。


14 N HDU 3081 Marriage Match II
二分+并查集+最大流
题意：
    n个女孩，n个男孩，m对男女孩可以配对，f对女孩互相认识，如果女孩互相认识则共有男孩，
    男女匹配问有多少种匹配方法（女孩每次都匹配不同的男孩）。
思路：
    源点s为0，汇点t为2*n+1。
    女孩编号[1, n]，男孩编号[n+1, 2*n]。
    假设我们当前二分尝试的轮数为K(即能够进行K轮匹配):
        首先如果女孩i可能选择男孩j，那么就有边(i, j+n, 1)。
        且源点到每个女孩i有边(s, i, k)，
        每个男孩j到汇点t有边(j+n, t, k)。
    如果最大流==k*n,那么就表示可以进行最少k轮匹配。


15 O HDU 3416 Marriage Match IV
题意：
    有n个城市，m条边，a到b耗费为c，为单向边。要求从s到t的最短路径有多少条，每一条边只能走一次。
分析：
    求出最短路径d1（由A出发的最短路径），d2（由B出发的最短路径），
    删除非最短路径的边（最短路径的边d1[a] + d2[b] + c == d1[B]）
    将最短路径的路线建图跑网络流，计算最大流

