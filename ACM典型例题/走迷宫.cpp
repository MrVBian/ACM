#include<bits/stdc++.h>
#include<algorithm>
using namespace std;

int m,n;
int b_x,b_y,e_x,e_y;
int row[100],col[100];
int k=1;
int step[][2]={{0,-1},{-1,0},{0,1},{1,0}};
int flag[100][100];
int mask=0;
int mp[100][100];

int OutBorder(int x,int y)
{
    if(x<1||x>m||y<1||y>n)  return 1;
    return 0;
}

void dfs(int x,int y)
{
    if(x==e_x && y==e_y){
        mask=1;
        for(int i=0;i<k;i++)
            printf(i==0?"(%d,%d)":"->(%d,%d)",row[i],col[i]);
        printf("\n");
        return ;
    }

    for(int i=0;i<4;i++){
        int cur_x=x+step[i][0];
        int cur_y=y+step[i][1];
        if( !OutBorder(cur_x,cur_y) && !flag[cur_x][cur_y] && mp[cur_x][cur_y] ){
            row[k]=cur_x;
            col[k]=cur_y;
            k++;
            flag[cur_x][cur_y]=1;
            dfs(cur_x,cur_y);
            flag[cur_x][cur_y]=0;
            k--;
        }
    }
}

int main()
{
    cin>>m>>n;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++)
            scanf(" %d",&mp[i][j]);
    }
    memset(flag,0,sizeof(flag));
    cin>>b_x>>b_y;
    cin>>e_x>>e_y;
    flag[1][1]=1;
    row[0]=b_x;
    col[0]=b_y;

//    printf("\n\n");
//    for(int i=1;i<=m;i++){
//        for(int j=1;j<=n;j++){
//            printf("%c ",mp[i][j]);
//        }
//        printf("\n");
//    }
    dfs(b_x,b_y);
    if(mask==0)
        printf("-1\n");
}

//roblem Description
//有一个m*n格的迷宫（表示有m行、n列），其中有可走的也有不可走的，如果用1表示可以走，0表示不可以走，输入这m*n个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用-1表示无路）。
//Input
//第一行是两个数m，n（1< m, n< 15)，接下来是m行n列由1和0组成的数据，最后两行是起始点和结束点。
//Output
//所有可行的路径，输出时按照左上右下的顺序。描述一个点时用（x，y）的形式，除开始点外，其他的都要用“->”表示。如果没有一条可行的路则输出-1。
//Sample Input
//5 4
//1 1 0 0
//1 1 1 1
//0 1 1 0
//1 1 0 1
//1 1 1 1
//1 1
//5 4
//Sample Output
//(1,1)->(1,2)->(2,2)->(2,3)->(3,3)->(3,2)->(4,2)->(4,1)->(5,1)->(5,2)->(5,3)->(5,4)
//(1,1)->(1,2)->(2,2)->(2,3)->(3,3)->(3,2)->(4,2)->(5,2)->(5,3)->(5,4)
//(1,1)->(1,2)->(2,2)->(3,2)->(4,2)->(4,1)->(5,1)->(5,2)->(5,3)->(5,4)
//(1,1)->(1,2)->(2,2)->(3,2)->(4,2)->(5,2)->(5,3)->(5,4)
//(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,2)->(4,2)->(4,1)->(5,1)->(5,2)->(5,3)->(5,4)
//(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,2)->(4,2)->(5,2)->(5,3)->(5,4)
//(1,1)->(2,1)->(2,2)->(3,2)->(4,2)->(4,1)->(5,1)->(5,2)->(5,3)->(5,4)
//(1,1)->(2,1)->(2,2)->(3,2)->(4,2)->(5,2)->(5,3)->(5,4)
