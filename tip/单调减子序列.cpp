#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>

using namespace std;

int dp[5001];
string a[5001];
string mo[5001];

int main()
{
    int n;
    memset(dp,0,sizeof(dp));
    cin>>n;
    for(int i=1;i<n+1;i++){
        cin>>a[i];
        dp[i]=1;
        mo[i]=a[i];
    }
    int Max=0;
    int ans=0;
    for(int i=2;i<n+1;i++){
        for(int j=1;j<i;j++){
            if( a[j].compare(a[i]) >0){
                if(dp[i]<dp[j]+1){
                    dp[i]=max(dp[i],dp[j]+1);
                    mo[i]+=a[j];
                }
            }
        }
        Max=max(Max,dp[i]);
    }
    for(int i=1;i<=n;i++)
        cout<<dp[i]<<' ';
    cout<<endl;
    for(int i=1;i<=n;i++)
        cout<<mo[i]<<' ';
    cout<<endl;
    for(int i=1;i<=n;i++){
        if(mo[i].length()==Max)
            ans++;
    }
    cout<<Max<<' '<<ans;
}
//从一个由
//NN
//N 个整数排列组成的整数序列中，自左向右不连续的选出一组整数，可以组成一个单调减小的子序列（如从
//[68,69,54,64,68,64,70,67,78,62,98,87][68, 69, 54, 64, 68, 64, 70, 67, 78, 62, 98, 87]
//[68,69,54,64,68,64,70,67,78,62,98,87] 中我们可以选取出
//[69,68,64,62][69, 68, 64, 62]
//[69,68,64,62] 这个子序列；当然，这里还有很多其他符合条件的子序列）。给定整数序列的长度和整数序列中依次的值，请你求出这个整数序列中“最长的单调减小的子序列的长度”以及“值不同但长度都是最长得单调减小的子序列的数量”。
//输入格式
//输入第
//11
//1 行为一个整数
//NN
//N，表示输入的整数序列的长度（
//1≤N≤50001 \leq N \leq 5000
//1≤N≤5000）。接下来会输入
//NN
//N 个整数（可能为一行或多行），每个整数都在
//3232
//32 位带符号长整型范围内。
//输出格式
//输出包括一行，为两个数字，分别为针对给定的整数序列求出的“最长的单调减小的子序列的长度”以及“值不同但长度都是最长得单调减小的子序列的数量”。
//样例输入
//12
//68 69 54 64 68 64
//70 67 78 62 98 87
//样例输出
//4 2
